---
title: "AI lab"
date: 2023-11-05T21:55:57+05:30
draft: false
---
# AI lab
## Week-1(from list)
```py
# -*- coding: utf-8 -*-
"""week1_listset.ipynb

Automatically generated by Colaboratory.

"""

list=[1,2,"shoaib",4,5]
print(list)

list1=[1,2,3,4]
list2=list1+["programming"]
print(list2)

list1.insert(2 ,9)
print(list1)

list1=[1,2,3]
list1.append(678)
print(list1)

list1=[1,2,3]
list1.extend([65,99.7])
print(list1)

list=[1,2,3,4,"python"]
list[4]="shoaib"
print(list)

del(list[2])
print(list)

list=[7,3,9,1,8]
list.sort()
print(list)

list.reverse()
print(list)

print(len(list))

print(sum(list))

print(min(list))

print(max(list))

print(9 in list)

#tuples
tup=(1,4,7,8)
print(tup)

tup=("shoaib",4,5,6)
print(tup)

tup=("shoaib",4,5,6)
tup_new=tup+("asim",17)
print(tup_new)

print(tup[0])

print(tup[1])

x=(1,("shoaib","asim"))
print(x[1][1])

print(x[0])

x=(1,("shoaib","asim"),("python","master"))
print(x[2,1])

print(x[2][1])

print(x[2][0])

#nested list
x=[1, ("shoaib"),("asim")]
print(x[1][1])

d={"usa":100,"uk":1000,"india":2220}
print(d)

d={"usa":100,"uk":[200,"shoaib"],"india":(300,"asim")}
print(d)

d={"usa":100,"uk":[200,"shoaib"],"india":(300,"asim")}
print(d["uk"])

d={"usa":100,"uk":[200,"shoaib"],"india":(300,"asim")}
del(d["usa"])

print(d)

#sets
set={'shoaib','asim','python','science'}
print(set)

set={'shoaib','asim','python','science','asim'}
print(set)

set={'shoaib','asim','python','science'}
print(set.add('add'))

set.add('add')
print(set)

set.remove('add')
print(set)

print(len(set))

s1={1,2,4,5,6}
s2={1,2,3,7,9}
print(s1&s2)

print(s1.intersection(s2))

print(s1|s2)

print(s1.union(s2))

def my_add(a):
    b=a+2
    return b
print(my_add(4))
```
## Week-2 (basics + BFS)
```py
# -*- coding: utf-8 -*-
"""week2bfs_s_q.ipynb

Automatically generated by Colaboratory.

"""

stack=[]


stack.append('a')
stack.append('b')
stack.append('c')
print(stack)

print(stack.pop())

print(stack.pop())

print(stack)

print(stack.pop())

print(stack.pop())

print(stack.pop())

queue=[]
print()

queue.append('a')
queue.append('b')
queue.append('c')
print("initial queue")
print(queue)

print(queue.pop(0))

print(queue.pop(0))

print(queue.pop(0))

from queue import PrioriyQueue
q=PriorityQueue()

q.put((2,'g'))
q.put((3,'e'))
print(q.get())

print(q)

print(q.get())

from queue import PriorityQueue
q=PriorityQueue

q.put((2,'g'))
q.put((3,'e'))
q.put((4,'k'))
q.put((5,'s'))
q.put((1,'e'))
print('item in queue',q.qsize())

from queue import PriorityQueue
q=PriorityQueue

q.put((2,'g'))
q.put((3,'e'))
q.put((4,'k'))
q.put((5,'s'))
q.put((1,'e'))
print('item in queue',q.qsize())
print(q.get())

from queue import PriorityQueue
q=PriorityQueue()

q.put((2,'g'))
q.put((3,'e'))
q.put((4,'k'))
q.put((5,'s'))
q.put((1,'e'))
print('item in queue',q.qsize())
print(q.get())
print(q.get())
print('item in queue',q.qsize())

print(q.empty())

print(q.full())

print(q.qsize())

print(q.get())

from queue import PriorityQueue
q=PriorityQueue()

q.put((2,'g'))
q.put((3,'e'))
q.put((4,'k'))
q.put((5,'s'))
q.put((1,'e'))
print('item in queue',q.qsize())

# Commented out IPython magic to ensure Python compatibility.
#tree
# %pip install treelib
from treelib import Tree
tree = Tree()
tree.create_node('shoaib','Shoaib')#root node
tree.create_node('jane','Jane',parent='Shoaib')
tree.show()

print(tree)



from treelib import Tree
tree=Tree()
tree.create_node(1,'shoaib')
tree.create_node(2,2,parent='shoaib')
tree.create_node(3,3,parent='shoaib')
tree.create_node(4,4,parent=2)
tree.create_node(5,5,parent=3)
tree.show()
print(tree)

#bfs
graph={
    '5':['3','7'],
    '3':['2','4'],
    '7':['8'],
    '2':[],
    '4':['8'],
    '8':[]


}

def bfs(graph,initial):
    visited=[]
    queue=[initial]

    while queue:
        node=queue.pop(0)
        if node not in visited:
            visited.append(node)
            neighbours = graph[node]

            for neighbour in neighbours:
                queue.append(neighbour)
    return visited

print(bfs(graph,'3'))





#bfs undirected graph
graph={
    '5':['3','7'],
    '3':['2','4','5'],
    '7':['8','5'],
    '2':['3'],
    '4':['8','3'],
    '8':['7']


}

def bfs(graph,initial):
    visited=[]
    queue=[initial]

    while queue:
        node=queue.pop(0)
        if node not in visited:
            visited.append(node)
            neighbours = graph[node]

            for neighbour in neighbours:
                queue.append(neighbour)
    return visited

print(bfs(graph,'3'))
```

## Week-3 (DFS and Best-fit-search)
```py
# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colaboratory.


"""

graph={
    '5':['3','7'],
    '3':['2','4','5'],
    '7':['8'],
    '2':[],
    '4':['8'],
    '8':[]
}
visited = set() # to keep track of nodes

def dfs(visited,graph,node):
    if node not in visited:
        print(node)
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)
#driver code
print("dfs")
dfs(visited,graph,'5')

graph={
    '5':['3','7'],
    '3':['2','4'],
    '7':['8'],
    '2':[],
    '4':['8'],
    '8':[]
}
visited = set() # to keep track of nodes

def dfs(visited,graph,node):
    if node not in visited:
        print(node)
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)
#driver code
print("dfs")
dfs(visited,graph,'3')

from queue import PriorityQueue
v = 14
graph = [[] for i in range(v)]

# Function For Implementing Best First Search
# Gives output path having lowest cost


def best_first_search(actual_Src, target, n):
    visited = [False] * n
    pq = PriorityQueue()
    pq.put((0, actual_Src))
    visited[actual_Src] = True

    while pq.empty() == False:
        u = pq.get()[1]
        # Displaying the path having lowest cost
        print(u, end=" ")
        if u == target:
            break

        for v, c in graph[u]:
            if visited[v] == False:
                visited[v] = True
                pq.put((c, v))
    print()

# Function for adding edges to graph


def addedge(x, y, cost):
    graph[x].append((y, cost))
    graph[y].append((x, cost))


# The nodes shown in above example(by alphabets) are
# implemented using integers addedge(x,y,cost);
addedge(0, 1, 3)
addedge(0, 2, 6)
addedge(0, 3, 5)
addedge(1, 4, 9)
addedge(1, 5, 8)
addedge(2, 6, 12)
addedge(2, 7, 14)
addedge(3, 8, 7)
addedge(8, 9, 5)
addedge(8, 10, 6)
addedge(9, 11, 1)
addedge(9, 12, 10)
addedge(9, 13, 2)

source = 0
target = 9
best_first_search(source, target, v)
```

## Week-4 (a* algo)
```py
def aStarAlgo(start_node, stop_node):
    open_set = set(start_node)
    closed_set = set()
    g = {}               #store distance from starting node
    parents = {}         # parents contains an adjacency map of all nodes
    #distance of starting node from itself is zero
    g[start_node] = 0
    #start_node is root node i.e it has no parent nodes
    #so start_node is set to its own parent node
    parents[start_node] = start_node
    while len(open_set) > 0:
        n = None
        #node with lowest f() is found
        for v in open_set:
            if n == None or g[v] + heuristic(v) < g[n] + heuristic(n):
                n = v
        if n == stop_node or Graph_nodes[n] == None:
            pass
        else:
            for (m, weight) in get_neighbors(n):
                #nodes 'm' not in first and last set are added to first
                #n is set its parent
                if m not in open_set and m not in closed_set:
                    open_set.add(m)
                    parents[m] = n
                    g[m] = g[n] + weight
                #for each node m,compare its distance from start i.e g(m) to the
                #from start through n node
                else:
                    if g[m] > g[n] + weight:
                        #update g(m)
                        g[m] = g[n] + weight
                        #change parent of m to n
                        parents[m] = n
                        #if m in closed set,remove and add to open
                        if m in closed_set:
                            closed_set.remove(m)
                            open_set.add(m)
        if n == None:
            print('Path does not exist!')
            return None
        
        # if the current node is the stop_node
        # then we begin reconstructin the path from it to the start_node
        if n == stop_node:
            path = []
            while parents[n] != n:
                path.append(n)
                n = parents[n]
            path.append(start_node)
            path.reverse()
            print('Path found: {}'.format(path))
            return path
        # remove n from the open_list, and add it to closed_list
        # because all of his neighbors were inspected
        open_set.remove(n)
        closed_set.add(n)
    print('Path does not exist!')
    return None

#define fuction to return neighbor and its distance
#from the passed node
def get_neighbors(v):
    if v in Graph_nodes:
        return Graph_nodes[v]
    else:
        return None
    
#for simplicity we ll consider heuristic distances given
#and this function returns heuristic distance for all nodes
def heuristic(n):
    H_dist = {
        'A': 11,
        'B': 6,
        'C': 99,
        'D': 1,
        'E': 7,
        'G': 0,
    }
    return H_dist[n]

#Describe your graph here
Graph_nodes = {
    'A': [('B', 2), ('E', 3)],
    'B': [('A', 2), ('C', 1), ('G', 9)],
    'C': [('B', 1)],
    'D': [('E', 6), ('G', 1)],
    'E': [('A', 3), ('D', 6)],
    'G': [('B', 9), ('D', 1)]
}

aStarAlgo('A', 'G')
```
## Week-5 (BFS-greedy and prolog)

```py
# bfs-greedy
from queue import PriorityQueue

v = 14
graph = [[] for i in range(v)]

# Function For Implementing Greedy Best First Search
# Gives output path having lowest cost

def greedy_best_first_search(actual_Src, target, n):
    visited = [False] * n
    pq = PriorityQueue()
    pq.put((0, actual_Src))
    visited[actual_Src] = True

    while pq.empty() == False:
        u = pq.get()[1]
        # Displaying the path having lowest cost
        print(u, end=" ")
        if u == target:
            break

        for v, c in graph[u]:
            if visited[v] == False:
                visited[v] = True
                pq.put((c, v))
    print()

# Function for adding edges to graph
def add_edge(x, y, cost):
    graph[x].append((y, cost))
    graph[y].append((x, cost))

# The nodes shown in above example (by alphabets) are
# implemented using integers add_edge(x, y, cost);
add_edge(0, 1, 3)
add_edge(0, 2, 6)
add_edge(0, 3, 5)
add_edge(1, 4, 9)
add_edge(1, 5, 8)
add_edge(2, 6, 12)
add_edge(2, 7, 14)
add_edge(3, 8, 7)
add_edge(8, 9, 5)
add_edge(8, 10, 6)
add_edge(9, 11, 1)
add_edge(9, 12, 10)
add_edge(9, 13, 2)

source = 0
target = 9
greedy_best_first_search(source, target, v)
```
### Prolog
```pl
likes(john,flowers).
likes(john,chicks).
likes(john,mangoes).
hates(john,oranges).
dislikes(john,study).
```
